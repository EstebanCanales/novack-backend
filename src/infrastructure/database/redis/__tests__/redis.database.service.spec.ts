import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { RedisDatabaseService } from '../redis.database.service';
import { StructuredLoggerService } from 'src/infrastructure/logging/structured-logger.service'; // Ensuring import is present

// Define a single, comprehensive mock Redis client instance
const mockRedisActualInstance = {
  on: jest.fn().mockReturnThis(), // Allow chaining for 'on'
  ping: jest.fn().mockResolvedValue('PONG'),
  set: jest.fn().mockResolvedValue('OK'),
  get: jest.fn(),
  lPush: jest.fn().mockResolvedValue(1),
  lTrim: jest.fn().mockResolvedValue('OK'),
  expire: jest.fn().mockResolvedValue(1),
  lRange: jest.fn(),
  multi: jest.fn().mockImplementation(function (this: any) { // Mock multi to be chainable
    this.chainedCommands = [];
    const chain = {
      get: (...args: any[]) => { (this.chainedCommands as any[]).push({ cmd: 'get', args }); return chain; },
      lRange: (...args: any[]) => { (this.chainedCommands as any[]).push({ cmd: 'lRange', args }); return chain; },
      // Add other commands that can be chained within multi
      exec: mockRedisActualInstance.exec, // Point to the shared exec mock
    };
    return chain;
  }),
  exec: jest.fn(), // This will be mocked per test if needed, or with a default above
  geoAdd: jest.fn().mockResolvedValue(1),
  geoSearchWith: jest.fn(),
  del: jest.fn().mockResolvedValue(1),
  flushAll: jest.fn().mockResolvedValue('OK'),
  connect: jest.fn().mockResolvedValue(undefined),
  quit: jest.fn().mockResolvedValue('OK'), // Added quit
  status: 'ready', // Added status
  sendCommand: jest.fn(), // Added sendCommand
  // Add any other methods that might be called
};

// Mock the 'redis' module's createClient to return this specific instance
jest.mock('redis', () => ({
  createClient: jest.fn(() => mockRedisActualInstance),
}));

describe('RedisDatabaseService', () => {
  let service: RedisDatabaseService;
  let configService: ConfigService;
  // mockMethods and MockRedis class are no longer needed

  beforeEach(async () => {
    // Reset all mocks on the instance before each test
    Object.values(mockRedisActualInstance).forEach(mockFn => {
      if (typeof mockFn === 'function' && 'mockClear' in mockFn) {
        mockFn.mockClear();
      }
    });
    // Re-establish default mock behaviors if they were changed in tests
    mockRedisActualInstance.ping.mockResolvedValue('PONG');
    mockRedisActualInstance.set.mockResolvedValue('OK');
    mockRedisActualInstance.lPush.mockResolvedValue(1);
    mockRedisActualInstance.lTrim.mockResolvedValue('OK');
    mockRedisActualInstance.expire.mockResolvedValue(1);
    mockRedisActualInstance.geoAdd.mockResolvedValue(1);
    mockRedisActualInstance.del.mockResolvedValue(1);
    mockRedisActualInstance.flushAll.mockResolvedValue('OK');
    mockRedisActualInstance.connect.mockResolvedValue(undefined);
    mockRedisActualInstance.on.mockReturnThis(); // Reset on to return this
    mockRedisActualInstance.multi.mockImplementation(function (this: any) {
        this.chainedCommands = [];
        const chain = {
            get: (...args: any[]) => { (this.chainedCommands as any[]).push({ cmd: 'get', args }); return chain; },
            lRange: (...args: any[]) => { (this.chainedCommands as any[]).push({ cmd: 'lRange', args }); return chain; },
            exec: mockRedisActualInstance.exec,
        };
        return chain;
    });


    jest.clearAllMocks(); // This might be redundant if individual mocks are cleared above but good for safety.
    
    // Setup del módulo de prueba con un mock de ConfigService
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RedisDatabaseService,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn().mockImplementation((key) => {
              if (key === 'REDIS_HOST') return 'redis-17374.c80.us-east-1-2.ec2.redns.redis-cloud.com';
              if (key === 'REDIS_PORT') return 17374;
              if (key === 'REDIS_USERNAME') return 'default';
              if (key === 'REDIS_PASSWORD') return 'vNrEVCdgtVb3A0Rr6Nb6H7JKKNxa4XYh';
              if (key === 'REDIS_ENCRYPTION_KEY') return 'secure_encryption_key_for_tests';
              return null;
            }),
          },
        },
        // Ensuring StructuredLoggerService mock is provided
        {
          provide: StructuredLoggerService,
          useValue: {
            setContext: jest.fn(),
            log: jest.fn(),
            error: jest.fn(),
            warn: jest.fn(),
            debug: jest.fn(),
            verbose: jest.fn(),
          },
        },
        {
          provide: 'REDIS_CLIENT_TYPE',
          useValue: mockRedisActualInstance, // Provide the single instance
        }
      ],
    }).compile();

    service = module.get<RedisDatabaseService>(RedisDatabaseService);
    configService = module.get<ConfigService>(ConfigService);
    await service.onModuleInit(); // Call onModuleInit
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('onModuleInit', () => {
    it('should initialize Redis client properly', async () => {
      // Ejecutar
      await service.onModuleInit();

      // Verificar conexión iniciada
      expect(mockRedisActualInstance.on).toHaveBeenCalledWith('connect', expect.any(Function));
      expect(mockRedisActualInstance.on).toHaveBeenCalledWith('error', expect.any(Function));
    });
  });

  describe('testConnection', () => {
    it('should verify Redis connection', async () => {
      // Ejecutar
      const result = await service.testConnection();

      // Verificar
      expect(mockRedisActualInstance.ping).toHaveBeenCalled();
      expect(result).toEqual({
        status: 'ok',
        message: 'Conexión a Redis Cloud establecida',
      });
    });
  });

  describe('saveChatMessage', () => {
    it('should save chat message to Redis', async () => {
      // Desactivar la encriptación para este test
      jest.spyOn(service as any, 'encrypt').mockImplementation((value) => value);
      
      const roomId = 'room123';
      const message = { id: 'msg456', content: 'Hola mundo' };

      // Ejecutar
      await service.saveChatMessage(roomId, message);

      // Verificar
      expect(mockRedisActualInstance.set).toHaveBeenCalledWith(
        `chat:message:${roomId}:${message.id}`,
        JSON.stringify(message),
        undefined // Las opciones son undefined si no se pasa ttl
      );
      expect(mockRedisActualInstance.lPush).toHaveBeenCalledWith(
        `chat:messages:${roomId}`,
        message.id,
      );
      expect(mockRedisActualInstance.lTrim).toHaveBeenCalledWith(
        `chat:messages:${roomId}`,
        0,
        99,
      );
    });
  });

  describe('getChatMessages', () => {
    it('should retrieve chat messages from Redis', async () => {
      // Desactivar la desencriptación para este test
      jest.spyOn(service as any, 'decrypt').mockImplementation((value) => value);
      
      const roomId = 'room123';
      const messageIds = ['msg456', 'msg789'];
      const mockMessages = {
        [`chat:message:${roomId}:msg456`]: JSON.stringify({ id: 'msg456', content: 'Hola' }),
        [`chat:message:${roomId}:msg789`]: JSON.stringify({ id: 'msg789', content: 'Mundo' }),
      };
      
      mockRedisActualInstance.lRange.mockResolvedValue(messageIds);
      mockRedisActualInstance.get.mockImplementation(key => Promise.resolve(mockMessages[key]));

      // Ejecutar
      const result = await service.getChatMessages(roomId);

      // Verificar
      expect(mockRedisActualInstance.lRange).toHaveBeenCalledWith(`chat:messages:${roomId}`, 0, 49);
      expect(mockRedisActualInstance.get).toHaveBeenCalledTimes(messageIds.length);
      expect(mockRedisActualInstance.get).toHaveBeenCalledWith(`chat:message:${roomId}:msg456`);
      expect(mockRedisActualInstance.get).toHaveBeenCalledWith(`chat:message:${roomId}:msg789`);
      expect(result).toHaveLength(2);
      expect(result[0].id).toBe('msg456');
      expect(result[1].id).toBe('msg789');
    });
  });

  describe('saveCardLocation', () => {
    it('should save card location to Redis', async () => {
      // Desactivar la encriptación para este test
      jest.spyOn(service as any, 'encrypt').mockImplementation((value) => value);
      
      const cardId = 'card123';
      const location = {
        latitude: 40.7128,
        longitude: -74.006,
        accuracy: 10.5,
      };

      // Ejecutar
      await service.saveCardLocation(cardId, location);

      // Verificar - ahora solo verificamos que se haya llamado con los argumentos correctos, sin importar los valores exactos
      expect(mockRedisActualInstance.set).toHaveBeenCalledWith(
        `card:location:${cardId}`,
        expect.any(String),
        expect.any(Object)
      );
      expect(mockRedisActualInstance.geoAdd).toHaveBeenCalledWith('cards:locations', {
        longitude: location.longitude,
        latitude: location.latitude,
        member: cardId
      });
    });
  });

  describe('getNearbyCards', () => {
    it('should find nearby cards using geospatial query', async () => {
      // Desactivar la desencriptación para este test
      jest.spyOn(service as any, 'decrypt').mockImplementation((value) => value);
      
      const latitude = 40.7128;
      const longitude = -74.006;
      const radius = 100;
      const mockResults = [
        ['card123', '50', ['-74.004', '40.715']],
        ['card456', '80', ['-74.009', '40.71']]
      ];
      
      mockRedisActualInstance.sendCommand.mockResolvedValue(mockResults);
      mockRedisActualInstance.get.mockImplementation((key) => {
        if (key === 'card:location:card123') {
          return Promise.resolve(JSON.stringify({ id: 'loc1', latitude: 40.715, longitude: -74.004, card_number: 'CARD-123' }));
        }
        if (key === 'card:location:card456') {
          return Promise.resolve(JSON.stringify({ id: 'loc2', latitude: 40.710, longitude: -74.009, card_number: 'CARD-456' }));
        }
        return Promise.resolve(null);
      });

      // Ejecutar
      const result = await service.getNearbyCards(latitude, longitude, radius);

      // Verificar
      expect(mockRedisActualInstance.sendCommand).toHaveBeenCalledWith([
        'GEOSEARCH', 
        'cards:locations', 
        'FROMLONLAT', 
        longitude.toString(), 
        latitude.toString(), 
        'BYRADIUS', 
        radius.toString(), 
        'm', 
        'WITHDIST', 
        'WITHCOORD',
        'ASC',
        'COUNT', 
        '50'
      ]);
      
      expect(result).toHaveLength(2);
      expect(result[0].distance_meters).toBe(50);
      expect(result[1].card_number).toBe('CARD-456');
    });
  });

  describe('generic cache methods', () => {
    beforeEach(() => {
      jest.spyOn(service as any, 'decrypt').mockImplementation((value) => value);
      jest.spyOn(service as any, 'shouldEncrypt').mockReturnValue(false);
    });
    
    it('should set and get values from cache', async () => {
      // Setup
      const key = 'test:key';
      const data = { name: 'Test', value: 123 };
      mockRedisActualInstance.get.mockResolvedValue(JSON.stringify(data));

      // Ejecutar set
      await service.set(key, data);

      // Verificar set
      expect(mockRedisActualInstance.set).toHaveBeenCalledWith(
        key,
        JSON.stringify(data),
        expect.any(Object)
      );

      // Ejecutar get
      const result = await service.get(key);

      // Verificar get
      expect(mockRedisActualInstance.get).toHaveBeenCalledWith(key);
      expect(result).toEqual(data);
    });

    it('should delete keys from cache', async () => {
      // Setup
      const keys = ['key1', 'key2', 'key3'];

      // Ejecutar
      await service.delete(...keys);

      // Verificar
      expect(mockRedisActualInstance.del).toHaveBeenCalledWith(keys);
    });

    it('should flush the cache', async () => {
      // Ejecutar
      await service.flushAll();

      // Verificar
      expect(mockRedisActualInstance.flushAll).toHaveBeenCalled();
    });
  });
}); 